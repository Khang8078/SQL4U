{
  "tutorial": [
    {
      "_id": "80101",
      "title": "Introduction",
      "contents": [
        {
          "header": "Databases",
          "detail": "Fields and records make up a table\nOne or more tables make up a database"
        },

        {
          "header": "Databases vs. Spreadsheets",
          "detail": "Both store data fields and records\nDatabase tables can have specific relationships to each other\nProgramming Foundations: Databases\nDatabases allow us to manage data and ask questions about data"
        },

        {
          "header": "SQL",
          "detail": "Write a question a computer can understand\nExpress what you mean explicitly\nOften is a series of smaller Questions\nAdopted into many DBMSs"
        },

        {
          "header": "SQL Statements",
          "detail": "A SQL statement is any SQL code that takes some kind of Application\nA SQL query is any statement that returns records"
        }
      ]
    },
    {
      "_id": "80102",
      "title": "Ask for Data from a Database",

      "contents": [
        { "header": "Ask for data with SELECT", "detail": " " },
        {
          "header": "The SQL SELECT Statement",
          "detail": "The SELECT statement is used to select data from a database.\nThe data returned is stored in a result table, called the result-set."
        },
        {
          "header": "SELECT Syntax",
          "detail": "SELECT column1, column2, ...\nFROM table_name;"
        },
        {
          "header": "The SQL SELECT DISTINCT Statement",
          "detail": "The SELECT DISTINCT statement is used to return only distinct (different) values.\nInside a table, a column often contains many duplicate values; and sometimes you only want to list the different (distinct) values."
        },
        {
          "header": "SELECT DISTINCT Syntax",
          "detail": "SELECT DISTINCT column1, column2, ...\nFROM table_name;"
        },

        { "header": "Narrow down a query with WHERE", "detail": " " },
        {
          "header": "The SQL WHERE Clause",
          "detail": "The WHERE clause is used to filter records.\nIt is used to extract only those records that fulfill a specified condition."
        },
        {
          "header": "WHERE Syntax",
          "detail": "SELECT column1, column2, ...\nFROM table_name\nWHERE condition;"
        },

        { "header": "Adding more criteria", "detail": " " },
        {
          "header": "The SQL AND, OR and NOT Operators",
          "detail": "The WHERE clause can be combined with AND, OR, and NOT operators.\nThe AND and OR operators are used to filter records based on more than one condition:\nThe AND operator displays a record if all the conditions separated by AND are TRUE.\nThe OR operator displays a record if any of the conditions separated by OR is TRUE.\nThe NOT operator displays a record if the condition(s) is NOT TRUE."
        },
        {
          "header": "AND Syntax",
          "detail": "SELECT column1, column2, ...\nFROM table_name\nWHERE condition1 AND condition2 AND condition3 ...;"
        },
        {
          "header": "OR Syntax",
          "detail": "SELECT column1, column2, ...\nFROM table_name\nWHERE condition1 OR condition2 OR condition3 ...;"
        },
        {
          "header": "NOT Syntax",
          "detail": "SELECT column1, column2, ...\nFROM table_name\nWHERE NOT condition;"
        },
        {
          "header": "Combining AND, OR and NOT",
          "detail": "You can also combine the AND, OR and NOT operators."
        },

        { "header": "Broadening and limiting responses", "detail": " " },
        {
          "header": "The SQL LIKE Operator",
          "detail": "The LIKE operator is used in a WHERE clause to search for a specified pattern in a column.\nThere are two wildcards often used in conjunction with the LIKE operator:\nThe percent sign (%) represents zero, one, or multiple characters\nThe underscore sign (_) represents one, single character "
        },
        {
          "header": "LIKE Syntax",
          "detail": "SELECT column1, column2, ...\nFROM table_name\nWHERE columnN LIKE pattern;"
        },

        { "header": "Organize responses with ORDER BY", "detail": " " },
        {
          "header": "The SQL ORDER BY Keyword",
          "detail": "The ORDER BY keyword is used to sort the result-set in ascending or descending order.\nThe ORDER BY keyword sorts the records in ascending order by default. To sort the records in descending order, use the DESC keyword."
        },
        {
          "header": "ORDER BY Syntax",
          "detail": "SELECT column1, column2, ...\nFROM table_name\nORDER BY column1, column2, ... ASC|DESC;"
        }
      ]
    },
    {
      "_id": "80103",
      "title": "Ask for Data from Two or More Tables",
      "contents": [
        {
          "header": "SQL JOIN",
          "detail": "A JOIN clause is used to combine rows from two or more tables, based on a related column between them."
        },
        {
          "header": "Different Types of SQL JOINs",
          "detail": "(INNER) JOIN: Returns records that have matching values in both tables\nLEFT (OUTER) JOIN: Returns all records from the left table, and the matched records from the right table\nRIGHT (OUTER) JOIN: Returns all records from the right table, and the matched records from the left table\nFULL (OUTER) JOIN: Returns all records when there is a match in either left or right table"
        },
        {
          "header": "SQL INNER JOIN Keyword",
          "detail": "The INNER JOIN keyword selects records that have matching values in both tables."
        },
        {
          "header": "INNER JOIN Syntax",
          "detail": "SELECT column_name(s)\nFROM table1\nINNER JOIN table2\nON table1.column_name = table2.column_name;"
        },
        {
          "header": "SQL LEFT JOIN Keyword",
          "detail": "The LEFT JOIN keyword returns all records from the left table (table1), and the matching records from the right table (table2). The result is 0 records from the right side, if there is no match."
        },
        {
          "header": "LEFT JOIN Syntax",
          "detail": "SELECT column_name(s)\nFROM table1\nLEFT JOIN table2\nON table1.column_name = table2.column_name;"
        },
        {
          "header": "SQL RIGHT JOIN Keyword",
          "detail": "The RIGHT JOIN keyword returns all records from the right table (table2), and the matching records from the left table (table1). The result is 0 records from the left side, if there is no match."
        },
        {
          "header": "RIGHT JOIN Syntax",
          "detail": "SELECT column_name(s)\nFROM table1\nRIGHT JOIN table2\nON table1.column_name = table2.column_name;"
        },
        {
          "header": "SQL FULL OUTER JOIN Keyword",
          "detail": "The FULL OUTER JOIN keyword returns all records when there is a match in left (table1) or right (table2) table records.\nTip: FULL OUTER JOIN and FULL JOIN are the same."
        },
        {
          "header": "FULL OUTER JOIN Syntax",
          "detail": "SELECT column_name(s)\nFROM table1\nFULL OUTER JOIN table2\nON table1.column_name = table2.column_name\nWHERE condition;"
        },
        {
          "header": "SQL Self Join",
          "detail": "A self join is a regular join, but the table is joined with itself."
        },
        {
          "header": "Self Join Syntax",
          "detail": "SELECT column_name(s)\nFROM table1 T1, table1 T2\nWHERE condition;"
        }
      ]
    },
    {
      "_id": "80104",
      "title": "Data Types, Math, and Helpful Features",
      "contents": [
        {
          "header": "Data types in SQL",
          "detail": "The kind of data stored in a field\nCan be text, numeric, binary, and so on.\nCertain operations are not possible with certain types\n+ Binary types: store short/long binary sequences\n+ Date and time types: store a value that should be treated as date/time data\n+ Number types: stores values as integers of various lengths, floating-point numbers, and so on\n+ Text types: store values intended to be used as text strings in. Fixed or variable numbers of characters\n+ Boolean type: stores a true or false value\n+ Null: represents a field having no value in it whatsoever. Not the same as false, no, or zero"
        },
        {
          "header": "Math in SQL",
          "detail": "Most basic: use a SELECT statement, such as SELECT 4+2\nSupports arithmetic operations: +, -, *, /, and %.\nAssumes integer operations unless otherwise specified\nSupports comparison operations: >,<,>=,<=,=<,!=,or<>"
        },
        {
          "header": "SQL Logical Operators",
          "detail": "ALL: TRUE if all of the subquery values meet the condition\nAND: TRUE if all the conditions separated by AND is TRUE\nANY: TRUE if any of the subquery values meet the condition\nBETWEEN: TRUE if the operand is within the range of comparisons\nEXISTS: TRUE if the subquery returns one or more records\nIN: TRUE if the operand is equal to one of a list of expressions\nLIKE: TRUE if the operand matches a pattern\nNOT: Displays a record if the condition(s) is NOT TRUE\nOR: TRUE if any of the conditions separated by OR is TRUE\nSOME: TRUE if any of the subquery values meet the condition"
        },
        {
          "header": "Creating aliases with AS",
          "detail": "SQL aliases are used to give a table, or a column in a table, a temporary name.\nAliases are often used to make column names more readable.\nAn alias only exists for the duration of that query.\nAn alias is created with the AS keyword."
        },
        {
          "header": "Alias Column Syntax",
          "detail": "SELECT column_name AS alias_name\nFROM table_name;"
        },
        {
          "header": "Alias Table Syntax",
          "detail": "SELECT column_name(s)\nFROM table_name AS alias_name;"
        }
      ]
    },
    {
      "_id": "80105",
      "title": "Add or Modify Data",
      "contents": [
        {
          "header": "Add data to a table",
          "detail": ""
        },
        {
          "header": "The SQL INSERT INTO Statement",
          "detail": "The INSERT INTO statement is used to insert new records in a table."
        },
        {
          "header": "INSERT INTO Syntax",
          "detail": "It is possible to write the INSERT INTO statement in two ways:\n1. Specify both the column names and the values to be inserted:\nINSERT INTO table_name (column1, column2, column3, ...)\nVALUES (value1, value2, value3, ...);\n2. If you are adding values for all the columns of the table, you do not need to specify the column names in the SQL query. However, make sure the order of the values is in the same order as the columns in the table. Here, the INSERT INTO syntax would be as follows:\nINSERT INTO table_name\nVALUES (value1, value2, value3, ...);"
        },
        {
          "header": "Modify data in a table",
          "detail": ""
        },
        {
          "header": "The SQL UPDATE Statement",
          "detail": "The UPDATE statement is used to modify the existing records in a table."
        },
        {
          "header": "UPDATE Syntax",
          "detail": "UPDATE table_name\nSET column1 = value1, column2 = value2, ...\nWHERE condition;"
        },
        {
          "header": "Removing data from a table",
          "detail": ""
        },
        {
          "header": "The SQL DELETE Statement",
          "detail": "The DELETE statement is used to delete existing records in a table."
        },
        {
          "header": "DELETE Syntax",
          "detail": "DELETE FROM table_name WHERE condition;"
        }
      ]
    },
    {
      "_id": "80106",
      "title": "Conclusion",
      "contents": [
        {
          "header": "The SQL UPDATE Statement",
          "detail": "The UPDATE statement is used to modify the existing records in a table."
        }
      ]
    },
    {
      "_id": "10101",
      "title": "Introduction",
      "contents": [
        {
          "header": "Why use a database",
          "detail": "Databases let us work with large amounts of data efficiently. They make updating data easy and reliable, and they help to ensure accuracy. They offer security features to control access to information, and they help us avoid redundancy. A database is a structure that stores information in an organized, consistent, reliable, and searchable way. And there are different kinds of databases intended for different use cases."
        },

        {
          "header": "What you should know",
          "detail": " A DBMS is the software, like SQL Server, MySQL or Access, we use to interact with the database. In this course, I'll be talking about databases in general and about the concepts that make relational databases work. You don't need any special software to follow along with the course, and you don't even need a database of your own."
        },

        {
          "header": "Understanding databases: Benefits of spreadsheets",
          "detail": "A database gives us a way to add structure to data and to define rules that the data must follow. The whole point of having data is to be able to use it for something, and a database gives us the tools both to protect data and to use data to answer questions."
        },

        {
          "header": "Understanding databases: Benefits of structured data",
          "detail": " A database can contain more than one table and databases offer the ability to create relationships between tables based on rules you define. We'll see more about this in detail later on. The structure of tables in the database is called the schema. If we start to add a little more information to our Customers and Orders tables, like a unique identifier for each row, now we can connect our orders to our customers and easily find out which dishes a customer has ordered."
        }
      ]
    },
    {
      "_id": "10102",
      "title": "Database foundations",
      "contents": [
        {
          "header": "Relational databases",
          "detail": "the most common is the relational database, which is named for the way that it organizes data into relations or tables of related data. In a relational database, tables are made up of rows, which represent instances of a given entity, and columns, which represent attributes of each entity. The set of columns is called a relation."
        },

        {
          "header": "Keys and unique values",
          "detail": " value we can use to refer to only one specific row or record. A primary key is the most important key in a table, though there can be others as well. A table doesn't require a primary key, but having one helps to access specific records easily."
        },

        {
          "header": "Relationships",
          "detail": " One to may, many to many, and one to one.\n A relationship starts out as something that exists in the model of the data. It's something we know about how the data will be used when we go to read or modify the data in the database. "
        },

        {
          "header": "ACID and transactions",
          "detail": "A transaction is a set of operations that must all be completed, and if for some reason any of the individual operations aren't completed, no changes are made to the database. Anything that's partially done will be undone. Transactions follow a set of principles outlined by the acronym ACID, which requires that the transactions be atomic, consistent, isolated, and durable. Atomic here means that the transaction is indivisible, that pieces of it can't be separated out."
        }
      ]
    },
    {
      "_id": "10103",
      "title": "Tables",
      "contents": [
        {
          "header": "Modeling and planning a database",
          "detail": "We'll start by doing a basic needs analysis. What does our database need to store? When you're designing a database, your needs will vary. We've seen examples from our restaurant database in this course, so let's plan out and build that database. In our restaurant, we want to keep track of customers, dishes, events, orders, and reservations."
        },

        {
          "header": "Naming tables",
          "detail": " Fields should be named singularly, because for each record, there's only one piece of data in the field."
        },

        {
          "header": "Columns and data types",
          "detail": "A string represents a collection of characters, or individual letters, numbers, and symbols. For string types and for some other types, the length of the information we're storing becomes important. Databases generally accept a handful of string types, including CHAR, a fixed length of characters, VARCHAR, a variable length of characters up to a certain limit, and longer text fields intended for something like a description. The database needs to know how long these fields are so it can efficiently store the information. "
        },

        {
          "header": "Numbers and other types",
          "detail": "Databases also offer specific data types for different kinds of numbers. These types are for integers, double precision numbers, floating point numbers, decimals of varying length, and more."
        }
      ]
    },
    {
      "_id": "10201",
      "title": "Git and GitHub Introduction",
      "contents": [
        {
          "header": "What is Git?",
          "detail": "Git is a popular version control system. It was created by Linus Torvalds in 2005, and has been maintained by Junio Hamano since then.\nIt is used for:\n+ Tracking code changes\n+ Tracking who made changes\n+ Coding collaboration"
        },
        {
          "header": "What does Git do?",
          "detail": "Manage projects with Repositories\nClone a project to work on a local copy\nControl and track changes with Staging and Committing\nBranch and Merge to allow for work on different parts and versions of a project\nPull the latest version of the project to a local copy\nPush local updates to the main project"
        },
        {
          "header": "Working with Git",
          "detail": "Initialize Git on a folder, making it a Repository\nGit now creates a hidden folder to keep track of changes in that folder\nWhen a file is changed, added or deleted, it is considered modified\nYou select the modified files you want to Stage\nThe Staged files are Committed, which prompts Git to store a permanent snapshot of the files\n Git allows you to see the full history of every commit.\nYou can revert back to any previous commit.\nGit does not store a separate copy of every file in every commit, but keeps track of changes made in each commit!"
        },
        {
          "header": "Why Git?",
          "detail": "Over 70% of developers use Git!\nDevelopers can work together from anywhere in the world.\nDevelopers can see the full history of the project.\nDevelopers can revert to earlier versions of a pro\n"
        },
        {
          "header": "What is GitHub?",
          "detail": "Git is not the same as GitHub.\nGitHub makes tools that use Git.\nGitHub is the largest host of source code in the world, and has been owned by Microsoft since 2018.\nIn this tutorial, we will focus on using Git with GitHub\n"
        }
      ]
    },
    {
      "_id": "10202",
      "title": "Git Getting Started",
      "contents": [
        {
          "header": "Git Install",
          "detail": "You can download Git for free from the following website: https://www.git-scm.com/"
        },
        {
          "header": "Using Git with Command Line",
          "detail": "To start using Git, we are first going to open up our Command shell.\nFor Windows, you can use Git bash, which comes included in Git for Windows. For Mac and Linux you can use the built-in terminal.\nThe first thing we need to do, is to check if Git is properly installed:\nExample\ngit --version\ngit version 2.30.2.windows.1"
        },
        {
          "header": "Configure Git",
          "detail": "Now let Git know who you are. This is important for version control systems, as each Git commit uses this information:\nExample\ngit config --global user.name w3schools-test\ngit config --global user.email test@w3schools.com\nChange the user name and e-mail address to your own. You will probably also want to use this when registering to GitHub later on."
        },
        {
          "header": "Creating Git Folder",
          "detail": "Now, let's create a new folder for our project:\nExample\nmkdir myproject\ncd myproject\nmkdir makes a new directory.\ncd changes the current working directory.\nNow that we are in the correct directory. We can start by initializing Git!"
        },
        {
          "header": "Initialize Git",
          "detail": "Once you have navigated to the correct folder, you can initialize Git on that folder:\nExample\ngit init \nInitialized empty Git repository in /Users/user/myproject/.git/\nYou just created your first Git Repository!"
        }
      ]
    },
    {
      "_id": "10203",
      "title": "Git New Files",
      "contents": [
        {
          "header": "Git Adding New Files",
          "detail": "You just created your first local Git repo. But it is empty.\nSo let's add some files, or create a new file using your favourite text editor. Then save or move it to the folder you just created.\nIf you want to learn how to create a new file using a text editor, you can visit our HTML tutorial:\nHTML Editors\nFor this example, I am going to use a simple HTML file like this:\n\nExample\n<!DOCTYPE html>\n<html>\n<head>\n<title>Hello World!</title>\n</head>\n<body>\n<h1>Hello world!</h1>\n<p>This is the first file in my new Git Repo.</p>\n</body>\n</html>\n\nAnd save it to our new folder as index.html.\\nLet's go back to the terminal and list the files in our current working directory:\nExample\nls\nindex.html\n\nls will list the files in the directory. We can see that index.html is there.\nThen we check the Git status and see if it is a part of our repo:\n\nExample\ngit status\nOn branch master\nNo commits yet\nUntracked files:\n  (use git add ... to include in what will be committed)\n    index.html\nnothing added to commit but untracked files present (use git add to track)\n\nNow Git is aware of the file, but has not added it to our repository!\nFiles in your Git repository folder can be in one of 2 states:\nTracked - files that Git knows about and are added to the repository\nUntracked - files that are in your working directory, but not added to the repository\n When you first add files to an empty repository, they are all untracked. To get Git to track them, you need to stage them, or add them to the staging environment.\nWe will cover the staging environment in the next chapter."
        }
      ]
    },
    {
      "_id": "10204",
      "title": "Git Staging Environment",
      "contents": [
        {
          "header": "Git Staging Environment",
          "detail": "One of the core functions of Git is the concepts of the Staging Environment, and the Comm\nAs you are working, you may be adding, editing and removing files. But whenever you hit a milestone or finish a part of the work, you should add the files to a Staging Environment.\nStaged files are files that are ready to be committed to the repository you are working on. You will learn more about commit shortly.\nFor now, we are done working with index.html. So we can add it to the Staging Environment:\n\nExample\ngit add index.html\n\nThe file should be Staged. Let's check the status::\n\nExample\ngit status\nOn branch master\nNo commits yet\nChanges to be committed:\n  (use git rm --cached ... to unstage)\n    new file: index.html\nNow the file has been added to the Staging Environment."
        },
        {
          "header": "Git Add More than One File",
          "detail": "You can also stage more than one file at a time. Let's add 2 more files to our working folder. Use the text editor again.\nA README.md file that describes the repository (recommended for all repositories):\n\nExample\n# hello-world\nHello World repository for Git tutorial\nThis is an example repository for the Git tutoial on https://www.w3schools.com\nThis repository is built step by step in the tutorial.\n\nA basic external style sheet (bluestyle.css):\n\nExample\nbody {\nbackground-color: lightblue;\n}\nh1 {\ncolor: navy;\nmargin-left: 20px;\n}\n\nAnd update index.html to include the stylesheet:\n\nExample\n<!DOCTYPE html>\n<html>\n<head>\n<link rel=stylesheet href=bluestyle.css>\n</head>\n<body>\n<h1>Hello world!</h1>\n<p>This is the first file in my new Git Repo.</p>\n</body>\n</html>\nNow add all files in the current directory to the Staging Environment:\n\nExample\ngit add --all\nUsing --all instead of individual filenames will stage all changes (new, modified, and deleted) files.\n\n\nExample\ngit status\nOn branch master\nNo commits yet\nChanges to be committed:\n  (use git rm --cached ... to unstage)\n        new file:   README.md\n        new file:   bluestyle.css\n        new file:   index.html\nNow all 3 files are added to the Staging Environment, and we are ready to do our first commit.\n"
        }
      ]
    },
    {
      "_id": "10205",
      "title": "Git Commit",
      "contents": [
        {
          "header": "Git Commit",
          "detail": "Since we have finished our work, we are ready move from stage to commit for our repo.\nAdding commits keep track of our progress and changes as we work. Git considers each commit change point or save point. It is a point in the project you can go back to if you find a bug, or want to make a change.\nWhen we commit, we should always include a message.\nBy adding clear messages to each commit, it is easy for yourself (and others) to see what has changed and when.\n\nExample\ngit commit -m First release of Hello World!\n[master (root-commit) 221ec6e] First release of Hello World!\n 3 files changed, 26 insertions(+)\n create mode 100644 README.md\n create mode 100644 bluestyle.css\n create mode 100644 index.html\nThe commit command performs a commit, and the -m message adds a message.\nThe Staging Environment has been committed to our repo, with the message:\nFirst release of Hello World!\n"
        },
        {
          "header": "Git Commit without Stage",
          "detail": "Sometimes, when you make small changes, using the staging environment seems like a waste of time. It is possible to commit changes directly, skipping the staging environment. The -a option will automatically stage every changed, already tracked file.\nLet's add a small update to index.html:\n\nExample\n<!DOCTYPE html>\n<html>\n<head>\n<title>Hello World!</title>\n<link rel=stylesheet href=bluestyle.css>\n</head>\n<body>\n<h1>Hello world!</h1>\n<p>This is the first file in my new Git Repo.</p>\n<p>A new line in our file!</p>\n</body>\n</html>\n\nAnd check the status of our repository. But this time, we will use the --short option to see the changes in a more compact way:\n\nExample\ngit status --short\n M index.html\n\nNote: Short status flags are:\n?? - Untracked files\nA - Files added to stage\nM - Modified files\nD - Deleted files\n\nWe see the file we expected is modified. So let's commit it directly:\n\nExample\ngit commit -a -m Updated index.html with a new line\n[master 09f4acd] Updated index.html with a new line\n 1 file changed, 1 insertion(+)"
        },
        {
          "header": "Git Commit Log",
          "detail": "To view the history of commits for a repository, you can use the log command:\n\nExample\ngit log\ncommit 09f4acd3f8836b7f6fc44ad9e012f82faf861803 (HEAD -> master)\nAuthor: w3schools-test \nDate:   Fri Mar 26 09:35:54 2021 +0100\n    Updated index.html with a new line\ncommit 221ec6e10aeedbfd02b85264087cd9adc18e4b26\nAuthor: w3schools-test \nDate:   Fri Mar 26 09:13:07 2021 +0100\n    First release of Hello World!"
        },
        { "header": "", "detail": "" }
      ]
    },
    {
      "_id": "10206",
      "title": "Git Help",
      "contents": [
        {
          "header": "Git Help",
          "detail": "If you are having trouble remembering commands or options for commands, you can use Git help\nThere are a couple of different ways you can use the help command in command line:\n\n+ git command -help -  See all the available options for the specific command\n\n+ git help --all -  See all possible commands\n Let's go over the different commands."
        },
        {
          "header": "Git -help See Options for a Specific Command",
          "detail": "Any time you need some help remembering the specific option for a command, you can use git command -help:\n\nExample\ngit commit -help\nusage: git commit [] [--] ...\n    -q, --quiet           suppress summary after successful commit\n    -v, --verbose         show diff in commit message template\nCommit message options\n    -F, --file      read message from file\n    --author      override author for commit\n    --date          override date for commit\n    -m, --message \n                          commit message\n    -c, --reedit-message \n                          reuse and edit message from specified commit\n    -C, --reuse-message \n                           reuse message from specified commit\n    --fixup       use autosquash formatted message to fixup specified commit\n    --squash      use autosquash formatted message to squash specified commit\n    --reset-author        the commit is authored by me now (used with -C/-c/--amend)\n    -s, --signoff         add a Signed-off-by trailer\n    -t, --template \n                          use specified template file\n    -e, --edit            force edit of commit\n    --cleanup       how to strip spaces and #comments from message\n    --status              include status in commit message template\n    -S, --gpg-sign[=]\n                          GPG sign commit\nCommit contents options\n    -a, --all             commit all changed files\n    -i, --include         add specified files to index for commit\n    --interactive         interactively add files\n    -p, --patch           interactively add changes\n    -o, --only            commit only specified files\n    -n, --no-verify       bypass pre-commit and commit-msg hooks\n    --dry-run             show what would be committed\n    --short               show status concisely\n    --branch              show branch information\n    --ahead-behind        compute full ahead/behind values\n    --porcelain           machine-readable output\n     --long                show status in long format (default)\n    -z, --null            terminate entries with NUL\n    --amend               amend previous commit\n    --no-post-rewrite     bypass post-rewrite hook\n    -u, --untracked-files[=]\n                          show untracked files, optional modes: all, normal, no. (Default: all)\n    --pathspec-from-file \n                          read pathspec from file\n    --pathspec-file-nul   with --pathspec-from-file, pathspec elements are separated with NUL character"
        },
        {
          "header": "Git help --all See All Possible Commands",
          "detail": "To list all possible commands, use the help --all command:\nWarning: This will display a very long list of commands\n\nExample\n$ git help --all\nSee 'git help ' to read about a specific subcommand\nMain Porcelain Commands\n   add                  Add file contents to the index\n   am                   Apply a series of patches from a mailbox\n   archive              Create an archive of files from a named tree\n   bisect               Use binary search to find the commit that introduced a bug\n   branch               List, create, or delete branches\n   bundle               Move objects and refs by archive\n   checkout             Switch branches or restore working tree files\n   cherry-pick          Apply the changes introduced by some existing commits\n   citool               Graphical alternative to git-commit\n   clean                Remove untracked files from the working tree\n   clone                Clone a repository into a new directory\n   commit               Record changes to the repository\n   describe             Give an object a human readable name based on an available ref\n   diff                 Show changes between commits, commit and working tree, etc\n   fetch                Download objects and refs from another repository\n   format-patch         Prepare patches for e-mail submission\n   gc                   Cleanup unnecessary files and optimize the local repository\n   gitk                 The Git repository browser\n   grep                 Print lines matching a pattern\n   gui                  A portable graphical interface to Git\n   init                 Create an empty Git repository or reinitialize an existing one\n   log                  Show commit logs\n   maintenance          Run tasks to optimize Git repository data\n   merge                Join two or more development histories together\n   mv                   Move or rename a file, a directory, or a symlink\n   notes                Add or inspect object notes\n   pull                 Fetch from and integrate with another repository or a local branch\n   push                 Update remote refs along with associated objects\n   range-diff           Compare two commit ranges (e.g. two versions of a branch)\n   rebase               Reapply commits on top of another base tip\n   reset                Reset current HEAD to the specified state\n   restore              Restore working tree files\n   revert               Revert some existing commits\n   rm                   Remove files from the working tree and from the index\n   shortlog             Summarize 'git log' output\n   show                 Show various types of objects\n   sparse-checkout      Initialize and modify the sparse-checkout\n   stash                Stash the changes in a dirty working directory away\n   status               Show the working tree status\n   submodule            Initialize, update or inspect submodules\n   switch               Switch branches\n   tag                  Create, list, delete or verify a tag object signed with GPG\n   worktree             Manage multiple working trees\nAncillary Commands / Manipulators\n   config               Get and set repository or global options\n   fast-export          Git data exporter\n   fast-import          Backend for fast Git data importers\n   filter-branch        Rewrite branches\n   mergetool            Run merge conflict resolution tools to resolve merge conflicts\n   pack-refs            Pack heads and tags for efficient repository access\n   prune                Prune all unreachable objects from the object database\n   reflog               Manage reflog information\n   remote               Manage set of tracked repositories\n   repack               Pack unpacked objects in a repository\n   replace              Create, list, delete refs to replace objects\nAncillary Commands / Interrogators\n   annotate             Annotate file lines with commit information\n  blame                Show what revision and author last modified each line of a file\n   bugreport            Collect information for user to file a bug report\n   count-objects        Count unpacked number of objects and their disk consumption\n   difftool             Show changes using common diff tools\n   fsck                 Verifies the connectivity and validity of the objects in the database\n   gitweb               Git web interface (web frontend to Git repositories)\n   help                 Display help information about Git\n   instaweb             Instantly browse your working repository in gitweb\n   merge-tree           Show three-way merge without touching index\n   rerere               Reuse recorded resolution of conflicted merges\n   show-branch          Show branches and their commits\n   verify-commit        Check the GPG signature of commits\n   verify-tag           Check the GPG signature of tags\n   whatchanged          Show logs with difference each commit introduces\nInteracting with Others\n   archimport           Import a GNU Arch repository into Git\n   cvsexportcommit      Export a single commit to a CVS checkout\n   cvsimport            Salvage your data out of another SCM people love to hate\n   cvsserver            A CVS server emulator for Git\n   imap-send            Send a collection of patches from stdin to an IMAP folder\n   p4                   Import from and submit to Perforce repositories\n   quiltimport          Applies a quilt patchset onto the current branch\n   request-pull         Generates a summary of pending changes\n   send-email           Send a collection of patches as emails\n   svn                  Bidirectional operation between a Subversion repository and Git\nLow-level Commands / Manipulators\n   apply                Apply a patch to files and/or to the index\n   checkout-index       Copy files from the index to the working tree\n   commit-graph         Write and verify Git commit-graph files\n   commit-tree          Create a new commit object\n   hash-object          Compute object ID and optionally creates a blob from a file\n   index-pack           Build pack index file for an existing packed archive\n   merge-file           Run a three-way file merge\n   merge-index          Run a merge for files needing merging\n   mktag                Creates a tag object\n   mktree               Build a tree-object from ls-tree formatted text\n   multi-pack-index     Write and verify multi-pack-indexes\n   pack-objects         Create a packed archive of objects\n   prune-packed         Remove extra objects that are already in pack files\n   read-tree            Reads tree information into the index\n   symbolic-ref         Read, modify and delete symbolic refs\n   unpack-objects       Unpack objects from a packed archive\n   update-index         Register file contents in the working tree to the index\n   update-ref           Update the object name stored in a ref safely\n   write-tree           Create a tree object from the current index\nLow-level Commands / Interrogators\n   cat-file             Provide content or type and size information for repository objects\n   cherry               Find commits yet to be applied to upstream\n   diff-files           Compares files in the working tree and the index\n   diff-tree            Compares the content and mode of blobs found via two tree objects\n   for-each-ref         Output information on each ref\n   for-each-repo        Run a Git command on a list of repositories\n   get-tar-commit-id    Extract commit ID from an archive created using git-archive\n   ls-files             Show information about files in the index and the working tree\n   ls-remote            List references in a remote repository\n   ls-tree              List the contents of a tree object\n   merge-base           Find as good common ancestors as possible for a merge\n   name-rev             Find symbolic names for given revs\n   pack-redundant       Find redundant pack files\n   rev-list             Lists commit objects in reverse chronological order\n   rev-parse            Pick out and massage parameters\n   show-index           Show packed archive index\n   show-ref             List references in a local repository\n   unpack-file          C\n   verify-pack          Validate packed Git archive files\nLow-level Commands / Syncing Repositories\n   daemon               A really simple server for Git repositories\n   fetch-pack           Receive missing objects from another repository\n   http-backend         Server side implementation of Git over HTTP\n   send-pack            Push objects over Git protocol to another repository\n   update-server-info   Update auxiliary info file to help dumb servers\nLow-level Commands / Internal Helpers\n   check-attr           Display gitattributes information\n   check-ignore         Debug gitignore / exclude files\n   check-mailmap        Show canonical names and email addresses of contacts\n   check-ref-format     Ensures that a reference name is well formed\n   column               Display data in columns\n   credential           Retrieve and store user credentials\n   credential-cache     Helper to temporarily store passwords in memory\n   credential-store     Helper to store credentials on disk\n   fmt-merge-msg        Produce a merge commit message\n   interpret-trailers   Add or parse structured information in commit messages\n   mailinfo             Extracts patch and authorship from a single e-mail message\n   mailsplit            Simple UNIX mbox splitter program\n   merge-one-file       The standard helper program to use with git-merge-index\n   patch-id             Compute unique ID for a patch\n   sh-i18n              Git's i18n setup code for shell scripts\n   sh-setup             Common Git shell script setup code\n   stripspace           Remove unnecessary whitespace\nExternal commands\n   askyesno\n   credential-helper-selector\n   flow\n   lfs\nNote: If you find yourself stuck in the list view, SHIFT + G to jump the end of the list, then q to exit the view."
        }
      ]
    },
    {
      "_id": "10207",
      "title": "Git Branch",
      "contents": [
        {
          "header": "Working with Git Branches",
          "detail": "In Git, a branch is a new/separate version of the main reposit\nLet's say you have a large project, and you need to update the design on it.\nHow would that work without and with Git:\n\nWithout Git:\n\tMake copies of all the relevant files to avoid impacting the live version\n\tStart working with the design and find that code depend on code in other files, that also need to be changed!\n\tMake copies of the dependant files as well. Making sure that every file dependency references the correct file name\n\tEMERGENCY! There is an unrelated error somewhere else in the project that needs to be fixed ASAP!\n\tSave all your files, making a note of the names of the copies you were working on\n\tWork on the unrelated error and update the code to fix it\n\tGo back to the design, and finish the work there\n\tCopy the code or rename the files, so the updated design is on the live version\n\t(2 weeks later, you realize that the unrelated error was not fixed in the new design version because you copied the files before the fix)\n\nWith Git:\n\tWith a new branch called new-design, edit the code directly without impacting the main branch\n\tEMERGENCY! There is a related error somewhere else in the project that needs to be fixed ASAP!\n\tCreate a new branch from the main project called small-error-fix\n\tFix the unrelated error and merge the small-error-fix branch with the main branch\n\tYou go back to the new-design branch, and finish the work there\n\tMerge the new-design branch with main (getting alerted to the small error fix that you were missing)\nBranches allow you to work on different parts of a project without impacting the main branch.\nWhen the work is complete, a branch can be merged with the main project.\nYou can even switch between branches and work on different projects without them interfering with each other.\nBranching in Git is very lightweight and fast!\n"
        },
        {
          "header": "New Git Branch",
          "detail": "Let add some new features to our index.html page.\nWe are working in our local repository, and we do not want to disturb or possibly wreck the main project.\nSo we create a new branch:\n\nExample\ngit branch hello-world-images\nNow we created a new branch called hello-world-images\nLet's confirm that we have created a new branch:\n\nExample\ngit branch\n  hello-world-images\n* master\nWe can see the new branch with the name hello-world-images, but the * beside master specifies that we are currently on that branch.\ncheckout is the command used to check out a branch. Moving us from the current branch, to the one specified at the end of the command:\n\n\nExample\ngit checkout hello-world-images\nSwitched to branch 'hello-world-images'\nNow we have moved our current workspace from the master branch, to the new branch\nOpen your favourite editor and make some changes.\nFor this example, we added an image (img_hello_world.jpg) to the working folder and a line of code in the index.html file:\n\nExample\n<!DOCTYPE html>\n<html>\n<head>\n<title>Hello World!</title>\n<link rel=stylesheet href=bluestyle.css>\n</head>\n<body>\n<h1>Hello worl!</h1>\n<div><img src=img_hello_world.jpg alt=Hello World from Space\nstyle=width:100%;max-width:960px></div>\n<p>This is the first file in my new Git Repo.</p>\n<p>A new line in our file!</p>\n</body>\n</html>\nWe have made changes to a file and added a new file in the working directory (same directory as the main branch).\nNow check the status of the current branch:\n\nExample\ngit status\nOn branch hello-world-images\nChanges not staged for commit:\n  (use git add ... to update what will be committed)\n  (use git restore ... to discard changes in working directory)\n        modified:   index.html\n\nUntracked files:\n  (use git add ... to include in what will be committed)\n        img_hello_world.jpg\nno changes added to commit (use git add and/or git commit -a)\nSo let's go through what happens here:\nThere are changes to our index.html, but the file is not staged for commit\nimg_hello_world.jpg is not tracked\nSo we need to add both files to the Staging Environment for this branch:\n\nExample\ngit add --all\nUsing --all instead of individual filenames will Stage all changed (new, modified, and deleted) files.\nCheck the status of the branch:\n\nExample\ngit status\nOn branch hello-world-images\nChanges to be committed:\n  (use git restore --staged ... to unstage)\n    new file: img_hello_world.jpg\n    modified: index.html\nWe are happy with our changes. So we will commit them to the branch:\n\nExample\ngit commit -m Added image to Hello World\n[hello-world-images 0312c55] Added image to Hello World\n2 files changed, 1 insertion(+)\ncreate mode 100644 img_hello_world.jpg\nNow we have a new branch, that is different from the master branch.\n"
        },
        {
          "header": "Switching Between Branches",
          "detail": "Now let's see just how quick and easy it is to work with different branches, and how well it works.\nWe are currently on the branch hello-world-images. We added an image to this branch, so let's list the files in the current directory:\n\nExample\nls\nREADME.md  bluestyle.css  img_hello_world.jpg  index.html\nWe can see the new file img_hello_world.jpg, and if we open the html file, we can see the code has been altered. All is as it should be.\nNow, let's see what happens when we change branch to master\n\nExample\ngit checkout master\nSwitched to branch 'master'\nThe new image is not a part of this branch. List the files in the current directory again:\n\nExample\nls\nREADME.md  bluestyle.css  index.html\nimg_hello_world.jpg is no longer there! And if we open the html file, we can see the code reverted to what it was before the alteration.\nSee how easy it is to work with branches? And how this allows you to work on different things?"
        },
        {
          "header": "Emergency Branch",
          "detail": "Now imagine that we are not yet done with hello-world-images, but we need to fix an error on master.\nI don't want to mess with master directly, and I do not want to mess with hello-world-images, since it is not done yet.\nSo we create a new branch to deal with the emergency:\n\nExample\ngit checkout -b emergency-fix\nSwitched to a new branch 'emergency-fix'\nNow we have created a new branch from master, and changed to it. We can safely fix the error without disturbing the other branches.\nLet's fix our imaginary error:\n\n\nExample\n<!DOCTYPE html>\n<html>\n<head>\n<title>Hello World!</title>\n<link rel=stylesheet href=bluestyle.css>\n</head>\n<body>\n<h1>Hello world!</h1>\n<p>This is the first file in my new Git Repo.</p>\n<p>This line is here to show how merging works.</p>\n</body>\n</html>\nWe have made changes in this file, and we need to get those changes to the master branch.\nCheck the status:\n\nExample\ngit status\nOn branch emergency-fix\nChanges not staged for commit:\n  (use git add ... to update what will be committed)\n  (use git restore ... to discard changes in working directory)\n        modified:   index.html\nno changes added to commit (use git add and/or git commit -a)\nstage the file, and commit:\nExample\ngit add index.html\ngit commit -m updated index.html with emergency fix\n[emergency-fix dfa79db] updated index.html with emergency fix\n 1 file changed, 1 insertion(+), 1 deletion(-)\nNow we have a fix ready for master, and we need to merge the two branches.\n"
        }
      ]
    },

    {
      "_id": "70101",
      "title": "NoSQL Tutorial: What is NoSQL",
      "contents": [
        {
          "header": "What is NoSQL?",
          "detail": "NoSQL Database is a non-relational Data Management System, that does not require a fixed schema. It avoids joins, and is easy to scale. The major purpose of using a NoSQL database is for distributed data stores with humongous data storage needs. NoSQL is used for Big data and real-time web apps. For example, companies like Twitter, Facebook and Google collect terabytes of user data every single day.\n\nNoSQL database stands for “Not Only SQL” or “Not SQL.” Though a better term would be “NoREL”, NoSQL caught on. Carl Strozz introduced the NoSQL concept in 1998.\n\nTraditional RDBMS uses SQL syntax to store and retrieve data for further insights. Instead, a NoSQL database system encompasses a wide range of database technologies that can store structured, semi-structured, unstructured and polymorphic data."
        },
        {
          "header": "Why NoSQL?",
          "detail": "The concept of NoSQL databases became popular with Internet giants like Google, Facebook, Amazon, etc. who deal with huge volumes of data. The system response time becomes slow when you use RDBMS for massive volumes of data.\nTo resolve this problem, we could “scale up” our systems by upgrading our existing hardware. This process is expensive.\nNoSQL database is non-relational, so it scales out better than relational databases as they are designed with web applications in mind."
        },
        {
          "header": "Brief History of NoSQL Databases",
          "detail": "+ 1998- Carlo Strozzi use the term NoSQL for his lightweight, open-source relational database\n+ 2000- Graph database Neo4j is launched\n+ 2004- Google BigTable is launched\n+ 2005- CouchDB is launched\n+ 2007- The research paper on Amazon Dynamo is released\n+ 2008- Facebooks open sources the Cassandra project\n+ 2009- The term NoSQL was reintroduced"
        },
        {
          "header": "Features of NoSQL",
          "detail": "Non-relational\n\t+ NoSQL databases never follow the relational model\n\t+ Never provide tables with flat fixed-column records\n\t+ Work with self-contained aggregates or BLOBs\n\t+ Doesn’t require object-relational mapping and data normalization\n\t+ No complex features like query languages, query planners,referential integrity joins, ACID\nSchema-free\t+ NoSQL databases are either schema-free or have relaxed schemas\t+ Do not require any sort of definition of the schema of the data\t+ Offers heterogeneous structures of data in the same domain\n\nSimple API\t+ Offers easy to use interfaces for storage and querying data provide\t+ APIs allow low-level data manipulation & selection method\t+ Text-based protocols mostly used with HTTP REST with JSO\t+ Mostly used no standard based NoSQL query languag\t+ Web-enabled databases running as internet-facing services\nDistributed\t+ Multiple NoSQL databases can be executed in a distributed fashio\t+ Offers auto-scaling and fail-over capabilitie\t+ Often ACID concept can be sacrificed for scalability and throughpu\t+ Mostly no synchronous replication between distributed nodes Asynchronous Multi-Master Replication, peer-to-peer, HDFS Replicatio\t+ Only providing eventual consistenc\t+ Shared Nothing Architecture. This enables less coordination and higher distribution."
        }
      ]
    },
    {
      "_id": "70102",
      "title": "Types of NoSQL Databases",
      "contents": [
        {
          "header": " ",
          "detail": "NoSQL Databases are mainly categorized into four types: Key-value pair, Column-oriented, Graph-based and Document-oriented. Every category has its unique attributes and limitations. None of the above-specified database is better to solve all the problems. Users should select the database based on their product needs.\nTypes of NoSQL Databases:\n\t + Key-value Pair Based\n\t + Column-oriented Graph\n\t + Graphs based\n\t + Document-oriented"
        },
        {
          "header": "Key Value Pair Based",
          "detail": "Data is stored in key/value pairs. It is designed in such a way to handle lots of data and heavy load.\nKey-value pair storage databases store data as a hash table where each key is unique, and the value can be a JSON, BLOB(Binary Large Objects), string, etc. It is one of the most basic NoSQL database example. This kind of NoSQL database is used as a collection, dictionaries, associative arrays, etc. Key value stores help the developer to store schema-less data. They work best for shopping cart contents.\nRedis, Dynamo, Riak are some NoSQL examples of key-value store DataBases. They are all based on Amazon’s Dynamo paper."
        },
        {
          "header": "Column-based",
          "detail": "Column-oriented databases work on columns and are based on BigTable paper by Google. Every column is treated separately. Values of single column databases are stored contiguously.\nThey deliver high performance on aggregation queries like SUM, COUNT, AVG, MIN etc. as the data is readily available in a column.\nColumn-based NoSQL databases are widely used to manage data warehouses, business intelligence, CRM, Library card catalogs\nHBase, Cassandra, HBase, Hypertable are NoSQL query examples of column based database."
        },
        {
          "header": "Document-Oriented:",
          "detail": "Document-Oriented NoSQL DB stores and retrieves data as a key value pair but the value part is stored as a document. The document is stored in JSON or XML formats. The value is understood by the DB and can be queried.\nIn this diagram on your left you can see we have rows and columns, and in the right, we have a document database which has a similar structure to JSON. Now for the relational database, you have to know what columns you have and so on. However, for a document database, you have data store like JSON object. You do not require to define which make it flexible.\nThe document type is mostly used for CMS systems, blogging platforms, real-time analytics & e-commerce applications. It should not use for complex transactions which require multiple operations or queries against varying aggregate structures\nAmazon SimpleDB, CouchDB, MongoDB, Riak, Lotus Notes, MongoDB, are popular Document originated DBMS systems."
        },
        {
          "header": "Graph-Based",
          "detail": "A graph type database stores entities as well the relations amongst those entities. The entity is stored as a node with the relationship as edges. An edge gives a relationship between nodes. Every node and edge has a unique identifier.\nCompared to a relational database where tables are loosely connected, a Graph database is a multi-relational in nature. Traversing relationship is fast as they are already captured into the DB, and there is no need to calculate them.\nGraph base database mostly used for social networks, logistics, spatial data.\nNeo4J, Infinite Graph, OrientDB, FlockDB are some popular graph-based databases."
        }
      ]
    },
    {
      "_id": "70103",
      "title": "Query Mechanism tools for NoSQL",
      "contents": [
        {
          "header": " ",
          "detail": "The most common data retrieval mechanism is the REST-based retrieval of a value based on its key/ID with GET resource\nDocument store Database offers more difficult queries as they understand the value in a key-value pair. For example, CouchDB allows defining views with MapReduce"
        },
        {
          "header": "What is the CAP Theorem? ",
          "detail": "CAP theorem is also called brewer’s theorem. It states that is impossible for a distributed data store to offer more than two out of three guarantees\n1.Consistency\n2.Availability\n3.Partition Tolerance\n\nConsistency:\nThe data should remain consistent even after the execution of an operation. This means once data is written, any future read request should contain that data. For example, after updating the order status, all the clients should be able to see the same data.\n\nAvailability:\nThe database should always be available and responsive. It should not have any downtime.\n\nPartition Tolerance:\nPartition Tolerance means that the system should continue to function even if the communication among the servers is not stable. For example, the servers can be partitioned into multiple groups which may not communicate with each other. Here, if part of the database is unavailable, other parts are always unaffected."
        },
        {
          "header": "Eventual Consistency ",
          "detail": "The term “eventual consistency” means to have copies of data on multiple machines to get high availability and scalability. Thus, changes made to any data item on one machine has to be propagated to other replica\nData replication may not be instantaneous as some copies will be updated immediately while others in due course of time. These copies may be mutually, but in due course of time, they become consistent. Hence, the name eventual consistency.\nBASE: Basically Available, Soft state, Eventual consistency\n\t +Basically, available means DB is available all the time as per CAP theorem\n\t +Soft state means even without an input; the system state may change\n\t +Eventual consistency means that the system will become consistent over time"
        },
        { "header": " ", "detail": "" }
      ]
    },
    {
      "_id": "70103",
      "title": "Advantages & Disadvantages of NoSQL",
      "contents": [
        {
          "header": "Advantages of NoSQL",
          "detail": "\n +Can be used as Primary or Analytic Data Source\n +Big Data Capability\n +No Single Point of Failure\n +Easy Replication\n +No Need for Separate Caching Layer\n +It provides fast performance and horizontal scalability.\n +Can handle structured, semi-structured, and unstructured data with equal effect\n +Object-oriented programming which is easy to use and flexible\n +NoSQL databases don’t need a dedicated high-performance server\n +Support Key Developer Languages and Platforms\n +Simple to implement than using RDBMS\n +It can serve as the primary data source for online applications.\n +Handles big data which manages data velocity, variety, volume, and complexity\n +Excels at distributed database and multi-data center operations\n +Eliminates the need for a specific caching layer to store data\n +Offers a flexible schema design which can easily be altered without downtime or service disruption"
        },
        {
          "header": "Disadvantages of NoSQL ",
          "detail": "\nNo standardization rules\nLimited query capabilities\nRDBMS databases and tools are comparatively mature\nIt does not offer any traditional database capabilities, like consistency when multiple transactions are performed simultaneously.\nWhen the volume of data increases it is difficult to maintain unique values as keys become difficult\nDoesn’t work as well with relational data\nThe learning curve is stiff for new developers\nOpen source options so not so popular for enterprises."
        }
      ]
    },
    {
      "_id": "70104",
      "title": "Conclusion",
      "contents": [
        {
          "header": "Summary",
          "detail": "\n + NoSQL is a non-relational DMS, that does not require a fixed schema, avoids joins, and is easy to scale\n+ The concept of NoSQL databases became popular with Internet giants like Google, Facebook, Amazon, etc. who deal with huge volumes of data\n+ In the year 1998- Carlo Strozzi use the term NoSQL for his lightweight, open-source relational database\n+ NoSQL databases never follow the relational model it is either schema-free or has relaxed schemas\n+ Four types of NoSQL Database are 1). Key-value Pair Based 2). Column-oriented Graph 3). Graphs based 4). Document-oriented\n+ NOSQL can handle structured, semi-structured, and unstructured data with equal effect\n+ CAP theorem consists of three words Consistency, Availability, and Partition Tolerance\n+ BASE stands for Basically Available, Soft state, Eventual consistency\n+ The term “eventual consistency” means to have copies of data on multiple machines to get high availability and scalability\n+ NOSQL offer limited query capabilities"
        }
      ]
    },
    {
      "_id": "70104",
      "title": "Conclusion",
      "contents": [
        {
          "header": "Summary",
          "detail": "\n + NoSQL is a non-relational DMS, that does not require a fixed schema, avoids joins, and is easy to scale\n+ The concept of NoSQL databases became popular with Internet giants like Google, Facebook, Amazon, etc. who deal with huge volumes of data\n+ In the year 1998- Carlo Strozzi use the term NoSQL for his lightweight, open-source relational database\n+ NoSQL databases never follow the relational model it is either schema-free or has relaxed schemas\n+ Four types of NoSQL Database are 1). Key-value Pair Based 2). Column-oriented Graph 3). Graphs based 4). Document-oriented\n+ NOSQL can handle structured, semi-structured, and unstructured data with equal effect\n+ CAP theorem consists of three words Consistency, Availability, and Partition Tolerance\n+ BASE stands for Basically Available, Soft state, Eventual consistency\n+ The term “eventual consistency” means to have copies of data on multiple machines to get high availability and scalability\n+ NOSQL offer limited query capabilities"
        }
      ]
    },
    {
      "_id": "30101",
      "title": "Introduction of Relational Database",
      "contents": [
        {
          "header": "Introduction",
          "detail": "The relational data model was introduced by C. F. Codd in 1970. Currently, it is the most widely used data model. The relational data model describes the world as “a collection of inter-related relations (or tables).” A relational data model involves the use of data tables that collect groups of elements into relations. These models work based on the idea that each table setup will include a primary key or identifier. Other tables use that identifier to provide relational data links and results. \nToday, there are many commercial Relational Database Management System (RDBMS), such as Oracle, IBM DB2, and Microsoft SQL Server. There are also many free and open-source RDBMS, such as MySQL, mSQL (mini-SQL) and the embedded Java DB (Apache Derby). Database administrators use Structured Query Language (SQL) to retrieve data elements from a relational database.\nAs mentioned, the primary key is a fundamental tool in creating and using relational data models. It must be unique for each member of a data set. It must be populated for all members. Inconsistencies can cause problems in how developers retrieve data. Other issues with relational database designs include excessive duplication of data, faulty or partial data, or improper links or associations between tables. A large part of routine database administration involves evaluating all the data sets in a database to make sure that they are consistently populated and will respond well to SQL or any other data retrieval method.\nFor example, a conventional database row would represent a tuple, which is a set of data that revolves around an instance or virtual object so that the primary key is its unique identifier. A column name in a data table is associated with an attribute, an identifier or feature that all parts of a data set have. These and other strict conventions help to provide database administrators and designers with standards for crafting relational database setups."
        },
        {
          "header": "Database Design Objective",
          "detail": "+ Eliminate Data Redundancy: the same piece of data shall not be stored in more than one place. This is because duplicate data not only waste storage spaces but also easily lead to inconsistencies.\n + Ensure Data Integrity and Accuracy:  is the maintenance of, and the assurance of the accuracy and consistency of, data over its entire life-cycle, and is a critical aspect to the design, implementation, and usage of any system which stores, processes, or retrieves data."
        },
        {
          "header": "Usage",
          "detail": "\n +Research on the theory of data/relationship/constraint\n\n +Numerous database design methodologies\n\n +The standard database access language called structured query language (SQL)\n\n +Almost all modern commercial database management systems\nRelational databases go together with the development of SQL. The simplicity of SQL - where even a novice can learn to perform basic queries in a short period of time - is a large part of the reason for the popularity of the relational model.\nThe two tables below relate to each other through the product code field. Any two tables can relate to each other simply by creating a field they have in common.\n"
        },
        {
          "header": "Stages",
          "detail": "There are four stages of an RDM which are as follows −\n + Relations and attributes − The various tables and attributes related to each table are identified. The tables represent entities, and the attributes represent the properties of the respective entities.\n + Primary keys − The attribute or set of attributes that help in uniquely identifying a record is identified and assigned as the primary key.\n + Relationships −The relationships between the various tables are established with the help of foreign keys. Foreign keys are attributes occurring in a table that are primary keys of another table. The types of relationships that can exist between the relations (tables) are One to one, One to many, and Many to many\n + Normalization − This is the process of optimizing the database structure. Normalization simplifies the database design to avoid redundancy and confusion. The different normal forms are as follows:                 1. First normal form                 2. Second normal form                 3. Third normal form                 4. Boyce-Codd normal form                 5. Fifth normal form\n\nBy applying a set of rules, a table is normalized into the above normal forms in a linearly progressive fashion. The efficiency of the design gets better with each higher degree of normalization."
        },
        {
          "header": "Advantages of Relational Databases",
          "detail": "The main advantages of relational databases are that they enable users to easily categorize and store data that can later be queried and filtered to extract specific information for reports. Relational databases are also easy to extend and aren't reliant on the physical organization. After the original database creation, a new data category can be added without all existing applications being modified."
        }
      ]
    },
    {
      "_id": "30102",
      "title": "Preventing Data Anomalies",
      "contents": [
        {
          "header": "Remove duplicate information",
          "detail": "Why Duplicates Matter\n + Slow performance\n + Maintenance issues\n +Inconsistencies and anomalies \n\n Removing Duplicates\n + Remove the dependent column\n + Copy the subject column"
        }
      ]
    },
    {
      "_id": "30103",
      "title": "Gathering Requirements",
      "contents": [
        {
          "header": "Understand the goal",
          "detail": "Creating a Mission Statement: \n+ Guides the database development process\n + Will guard against scope creep\n + Developed with project initiator\n + Focused on the goal, not hte task\n\n Writing Mission Objectives: \n+ Short sentences that support the mission statement\n + Describe the task that need to be performed\n + Usually revealed by frontline workers\n\n Two Trees Mission Objectives: \n + Maintain information on our product selection\n + Keep a live inventory count on product availability\n + Provide order details to the shipping warehouse\n + Provide order details to the shipping warehouse\n + Provide customers with order invoices and tracking"
        },
        {
          "header": "Review the current system",
          "detail": "Locating Current Records:\n +Outdated computer database\n +Spreadsheets files\n +Paper records in file folders or cabinets\n +Always keep the mission statement in mind\n\n Locating Current Data Exports:\n + Summary reports\n + Transaction logs\n + Directories\n + Invoices and receipts "
        },
        {
          "header": "Discover actors and tasks",
          "detail": "Locating Stakeholders:\n + Identify groups of people that interact with the system\n + User groups are called actors\n + Actors represent the same position or role\n\n Possible Actors for Two Trees:\n + Account executive\n + Salesperson\n +Warehouse manager\n + May all the same person"
        },
        {
          "header": "Interview the client",
          "detail": "Identify Interview Subjects:\n + Locate specific people in each actor group\n + Seek out the ones with the most knowledge or experience\n + Sometimes known as subject matter experts\n + May also be a single point of contact\n\n Conduct an Interview:\n + Come prepared with questions\n + Keep the interview on topic\n + Ask open-ended questions for general overviews\n + Ask closed questions for specific details\n\n Business Rules:\n + Formal or informal constraints placed on data\n + May be written in a company manual\n + Or just known by everyone in the organization "
        },
        {
          "header": "Identify exceptions and irregularities",
          "detail": "Exceptional and Irregular Items:\n + Customer name\n + Business name\n + Credit card\n + Purchase order number"
        }
      ]
    },
    {
      "_id": "30104",
      "title": "Developing the Conceptual Data Model",
      "contents": [
        {
          "header": "Understand entities and tables",
          "detail": "Building a Data Model:\n + Graphical representation of the database\n + Your construction blueprint\n + Visualizes tables and their fields\n + Clarifies relationships between tables\n\n Identifying Tables:\n + Organize field list into logical groupings\n + Fields will characterize common subjects\n + Document review and interviews will guide the process\n\nTable Diagrams:\n + Each table is represented by a rectangle\n + Fields are listed below the entity name\n + Entities are connected by lines to represent relationships\n + Symbols are added to denote the type of relationships  "
        },
        {
          "header": "Utilize lookup tables",
          "detail": "What Are Lookup Tables?\n + Determined by business rules\n + Help support data consistency\n + Create a finite list of acceptable values\n + Implemented as drop-down list or combo box"
        },
        {
          "header": "Draft the initial data model",
          "detail": "+ Organize tables into a model of your system\n + Create relationships between entities\n + Get the draft down on paper so you can see the bigger picture"
        }
      ]
    },
    {
      "_id": "30105",
      "title": "Normalizing Your Data",
      "contents": [
        {
          "header":"Identify key fields",
          "detail":"Primary Keys:\n + Must be unique\n + Cannot be NULL\n + Must be given a value when the record is created"
        },
        {
          "header":"Denormalization",
          "detail":"Why Denormalize a Table?\n + Performance of the system\n + Historical data tracking"
        },
        {
          "header": "",
          "detail":""
        }
      ]
    },
    {
      "_id": "30106",
      "title": "Logical Design Considerations",
      "contents": [{
        "header":"Follow a naming convention",
        "detail":"Naming Convention:\n + Documents the structure of the database\n + Helps others understand your design decisions\n\n For example:\n 1. Be Consistent:\n + First-Name, Last-Name, Department\n + FIRST_NAME, LAST_NAME, DEPARTMENT\n + FirstName, LastName, Department\n 2. Avoid Special Characters:\n + Don't use space in the table or field names\n + Use alphanumeric characters only\n + Don't use brackets or parenthesis\n 3.Know the Reserved Words:\n + Special lists of words that are used by DBMS\n + SELECT\n + CREATE\n + DATE, TIME, NAME, CHARACTER, GROUP\n + Review the list of your specific DBMS"
      },
      {
        "header":"Data types and precision",
        "detail":"Storing Text Data:\n + Allows alphanumeric characters and symbols\n + Options for small strings of characters or large blocks\n + Can also store text of a variable length or fixed length\n + SQL Server - varchar(50)\n + Microsoft Access\n\n Long Text Fields:\n + CLOB - character large objects\n + SQL Server - varchar(max)\n + Microsoft Access\n\n Numeric Data Can Also Be Text:\n + Phone numbers\n + ZIP codes\n + Any field that wouldn't involve a mathematical operation\n\n Storing Numbers as Numbers: \n Exact number \n + Whole or fractional values\n + Numeric, decimal, integer, bigint, or smallint\n Approximate numbers\n + Represent very large or vary small values\n + Float, real, single precision, or double precision\n\n    "
      },
      {
        "header": "Apply integrity constraints",
        "detail":"Controlling Data Input:\n Can implement through a related table\n + Used to look up valid inputs from a specific list\n + Includes all the possible responses to a field\n Create a check constraint\n + Built into the table structure itself\n + Also used to limit the entry to only approved responses.\n\n Controlling Numerical Input:\n + Numbers within an acceptable range\n + Controlling date entries\n + Dictated by the requirement gathering phas\n\n Required Fields:\n + Implemented with a NULL constraint\n + If required, the field must be NOT NULL\n + Determine usage from business rules"
      },
      {
        "header": "Enforce referential integrity",
        "detail":"Enforcing Referential Integrity:\n Relationship-level constraint\n + Data integrity rule\n + Prevents orphaned records from occurring"
      },
      {
        "header": "Build indexes",
        "detail":"Adding Too Many Indexes:\n + Slows down the write speed of the database\n + Every edit causes all of the indexes to be rebuilt\n + Searches still possible on non-indexed fields\n + Efficiencies depend on the size of the data tables"
      }
    ]
    },
    {
      "_id": "30107",
      "title": "Developing the Physical Database",
      "contents": [{
        "header": "Move from planning to construction",
        "detail":"The Path to Construction:\n 1. Create a well-defined mission statement\n 2. Develop specific mission objectives\n 3. Identify actors and subject matter experts to interview\n 4. Create an initial list of data elements that will need to be stored in the database\n 5. Organize elements into tables to create a model\n 6. Add additional fields to support a good relational design\n 7. Consider naming conventions, data types, and constraints"
      },
      {
        "header": "Introduction to Access",
        "detail":"Create the tables in Access: https://support.microsoft.com/en-us/office/decide-whether-to-create-a-desktop-database-or-an-access-web-app-7bf7ccc9-0850-48f2-858f-273271d30fa0?wt.mc_id=otc_access# \n\n Establish relationships in Access: https://support.microsoft.com/en-us/office/video-get-started-with-table-relationships-728d53ff-f332-4ac6-9382-574ee271500a?wt.mc_id=otc_access# \n\n  "
      },{
        "header":"Write queries in Access",
        "detail":"https://support.microsoft.com/en-us/office/video-get-started-with-queries-07e75b65-5eda-414f-b822-ea4e7aaf1ccb?wt.mc_id=otc_access#"
      },
      {
        "header":"Write queries in Access",
        "detail":"https://support.microsoft.com/en-us/office/video-get-started-with-queries-07e75b65-5eda-414f-b822-ea4e7aaf1ccb?wt.mc_id=otc_access#"
      },
      {
        "header":"Add and edit",
        "detail":"https://support.microsoft.com/en-us/office/video-copy-data-from-excel-b0bee2b9-e721-4332-869d-51fc9180f411?wt.mc_id=otc_access#"
      }
    ]
    }
  ]
}
